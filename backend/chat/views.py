from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.http import JsonResponse
from knowledge.models import ChatHistory, UserFeedback
from ai_models.services import chatbot_ai
from ai_models.speech_service import speech_service  # ‚Üê TH√äM IMPORT
import uuid
import time
import logging
import json
import tempfile
import os
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile

logger = logging.getLogger(__name__)

def get_client_ip(request):
    """Get client IP address"""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip

class APIRootView(APIView):
    """API Root - Hi·ªÉn th·ªã danh s√°ch endpoints"""
    def get(self, request):
        
        test_memory = request.GET.get('test_memory')
        if test_memory:
            try:
                memory = chatbot_ai.get_conversation_memory(test_memory)
                return Response({
                    'memory_test': True,
                    'session_id': test_memory,
                    'memory': memory,
                    'total_sessions': len(chatbot_ai.response_generator.memory.conversations)
                })
            except Exception as e:
                return Response({
                    'memory_test': True,
                    'error': str(e)
                })
        
        system_status = chatbot_ai.get_system_status()
        
        # ‚úÖ TH√äM: Speech service status
        speech_status = speech_service.get_system_status()
        
        return Response({
            'message': 'Chatbot API - ƒê·∫°i h·ªçc B√¨nh D∆∞∆°ng',
            'version': '3.1.0',  # ‚Üê TƒÉng version
            'status': 'active',
            'system_status': system_status,
            'speech_status': speech_status,  # ‚Üê TH√äM
            'endpoints': {
                'chat': '/api/chat/',
                'health': '/api/health/',
                'history': '/api/history/',
                'feedback': '/api/feedback/',
                'speech_to_text': '/api/speech-to-text/',  # ‚Üê TH√äM
                'speech_status': '/api/speech-status/',    # ‚Üê TH√äM
            },
            'features': [
                'Natural Language Generation',
                'Intent Classification',
                'Conversation Memory',
                'Emotional Context',
                'UTF-8 Safe Encoding',
                'Speech-to-Text (Whisper)',  # ‚Üê TH√äM
            ]
        })

class ChatView(APIView):
    """Enhanced Chat API with Natural Responses"""
    
    def get(self, request):
        """GET method - API information"""
        system_status = chatbot_ai.get_system_status()
        speech_status = speech_service.get_system_status()  # ‚Üê TH√äM
        
        return Response({
            'message': 'Natural Language Chat API',
            'system_status': system_status,
            'speech_status': speech_status,  # ‚Üê TH√äM
            'method': 'POST ƒë·ªÉ g·ª≠i tin nh·∫Øn',
            'features': [
                'PhoBERT Intent Classification',
                'SBERT + FAISS Retrieval',
                'Conversation Memory',
                'UTF-8 Safe Processing',
                'Speech-to-Text Integration'  # ‚Üê TH√äM
            ]
        })
    
    def post(self, request):
        """POST method - Process chat with personalization support"""
        start_time = time.time()
        
        try:
            # Get and validate input
            user_message = request.data.get('message', '').strip()
            session_id = request.data.get('session_id', str(uuid.uuid4()))
            
            # ‚úÖ TH√äM: L·∫•y user_id ƒë·ªÉ personalization
            user_id = request.user.id if request.user.is_authenticated else None
            
            print(f"üîç CHAT DEBUG: user_id = {user_id}, session_id = {session_id}")
            print(f"üîç CHAT DEBUG: User message = {user_message}")
            
            if not user_message:
                return Response(
                    {'error': 'Tin nh·∫Øn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            if len(user_message) > 1000:
                return Response(
                    {'error': 'Tin nh·∫Øn qu√° d√†i (t·ªëi ƒëa 1000 k√Ω t·ª±)'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # ENSURE UTF-8 encoding
            try:
                user_message = user_message.encode('utf-8').decode('utf-8')
            except UnicodeError:
                user_message = user_message.encode('utf-8', errors='ignore').decode('utf-8')
            
            # ‚úÖ TH√äM: L·∫•y user context n·∫øu c√≥
            user_context = None
            if user_id and request.user.is_authenticated:
                try:
                    user_context = request.user.get_chatbot_context()
                    print(f"üë§ USER CONTEXT: {user_context.get('role_description', 'Unknown')}")
                except Exception as e:
                    logger.warning(f"Could not get user context: {e}")
            
            logger.info(f"üí¨ Processing: {user_message[:50]}... (User: {user_context.get('faculty_code') if user_context else 'Anonymous'})")
            
            # ‚úÖ TH√äM: Process v·ªõi user context
            if user_context:
                # S·ª≠ d·ª•ng personalized processing
                ai_response = self._process_with_personalization(user_message, session_id, user_context)
            else:
                # S·ª≠ d·ª•ng processing th√¥ng th∆∞·ªùng
                ai_response = chatbot_ai.process_query(user_message, session_id)
            
            print(f"üîç CHAT DEBUG: AI response method = {ai_response.get('method', 'unknown')}")
            
            # ENSURE UTF-8 safe response
            response_text = ai_response['response']
            try:
                response_text = response_text.encode('utf-8').decode('utf-8')
            except UnicodeError:
                response_text = response_text.encode('utf-8', errors='ignore').decode('utf-8')
            
            # Clean response text
            response_text = self._clean_response_text(response_text)
            
            processing_time = time.time() - start_time
            
            # Save chat history v·ªõi user context
            try:
                chat_record = ChatHistory.objects.create(
                    session_id=session_id,
                    user_message=user_message,
                    bot_response=response_text,
                    confidence_score=ai_response.get('confidence', 0.7),
                    response_time=processing_time,
                    user_ip=get_client_ip(request),
                    # ‚úÖ TH√äM: L∆∞u user context v√†o entities
                    entities=json.dumps({
                        'user_context': user_context,
                        'personalized': bool(user_context)
                    }) if user_context else None
                )
                logger.info(f"‚úÖ Chat saved: {chat_record.id}")
            except Exception as e:
                logger.error(f"Error saving chat: {str(e)}")
            
            # Return enhanced response
            return Response({
                'session_id': session_id,
                'response': response_text,
                'confidence': ai_response['confidence'],
                'method': ai_response.get('method', 'hybrid'),
                'intent': ai_response.get('intent', {}).get('intent', 'general'),
                'sources': ai_response.get('sources', []),
                'response_time': processing_time,
                'status': 'success',
                'encoding': 'utf-8',
                # ‚úÖ TH√äM: Personalization info
                'personalized': bool(user_context),
                'user_context': {
                    'department': user_context.get('department_name') if user_context else None,
                    'position': user_context.get('position_name') if user_context else None,
                    'faculty_code': user_context.get('faculty_code') if user_context else None
                } if user_context else None
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"‚ùå Chat error: {str(e)}")
            
            # Safe fallback response v·ªõi personalization
            fallback_response = self._get_safe_fallback_response_personalized(
                locals().get('user_message', ''),
                locals().get('user_context')
            )
            
            return Response({
                'session_id': locals().get('session_id', str(uuid.uuid4())),
                'response': fallback_response,
                'confidence': 0.3,
                'method': 'safe_fallback',
                'response_time': time.time() - start_time,
                'status': 'fallback',
                'personalized': bool(locals().get('user_context'))
            })
    
    def _get_safe_fallback_response_personalized(self, user_message='', user_context=None):
        """Safe fallback response v·ªõi personalization"""
        if user_context:
            full_name = user_context.get('full_name', '')
            faculty_code = user_context.get('faculty_code', '')
            name_suffix = full_name.split()[-1] if full_name else faculty_code
            personal_address = f"th·∫ßy/c√¥ {name_suffix}"
            department_name = user_context.get('department_name', 'BDU')
            
            return f"""D·∫° xin l·ªói {personal_address}, h·ªá th·ªëng ƒëang ƒë∆∞·ª£c c·∫£i thi·ªán ƒë·ªÉ ph·ª•c v·ª• {personal_address} t·ªët h∆°n.

Trong th·ªùi gian n√†y, {personal_address} c√≥ th·ªÉ:
‚Ä¢ Li√™n h·ªá tr·ª±c ti·∫øp khoa {department_name}
‚Ä¢ G·ªçi t·ªïng ƒë√†i: 0274.xxx.xxxx  
‚Ä¢ Email: info@bdu.edu.vn
‚Ä¢ Website: www.bdu.edu.vn

C·∫£m ∆°n {personal_address} ƒë√£ ki√™n nh·∫´n! üòä"""
        
        return self._get_safe_fallback_response(user_message)
    
    # ‚úÖ TH√äM: Method m·ªõi ƒë·ªÉ x·ª≠ l√Ω personalization
    def _process_with_personalization(self, message, session_id, user_context):
        """Process message v·ªõi personalization"""
        try:
            # S·ª≠ d·ª•ng gemini service v·ªõi personalization
            from ai_models.gemini_service import GeminiResponseGenerator
            
            # T·∫°o enhanced context
            enhanced_context = {
                'user_context': user_context,
                'force_education_response': True,
                'personalized': True
            }
            
            # G·ªçi generate_response_personalized n·∫øu c√≥
            gemini_generator = GeminiResponseGenerator()
            base_response = chatbot_ai.process_query(message, session_id)

            # Sau ƒë√≥ enhance v·ªõi personalization
            if hasattr(gemini_generator, 'enhance_with_personalization'):
                return gemini_generator.enhance_with_personalization(base_response, user_context)
            else:
                return base_response
                
        except Exception as e:
            logger.error(f"Personalized processing error: {e}")
            # Fallback to regular processing
            return chatbot_ai.process_query(message, session_id)
    
    def _clean_response_text(self, text):
        """Clean and ensure safe UTF-8 text"""
        import re
        
        # Remove control characters and invalid UTF-8
        text = re.sub(r'[\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x84\x86-\x9f]', '', text)
        
        # Fix common encoding issues
        text = text.replace('√¢‚Ç¨‚Ñ¢', "'")
        text = text.replace('√¢‚Ç¨≈ì', '"')
        text = text.replace('√¢‚Ç¨', '"')
        text = text.replace('√¢‚Ç¨"', '-')
        
        # # Remove any garbled Vietnamese characters patterns
        # text = re.sub(r'[·∫§·∫¨·∫¶·∫®·∫™ƒÇ·∫Æ·∫∂·∫∞·∫≤·∫¥√Ç·∫§·∫¨·∫¶·∫®·∫™√â·∫æ·ªÜ·ªÄ·ªÇ·ªÑ√ä·∫æ·ªÜ·ªÄ·ªÇ·ªÑ√ç·ªä√å·ªàƒ®√ì·ªò√í·ªé√ï√î·ªê·ªò·ªí·ªî·ªñ∆†·ªö·ª¢·ªú·ªû·ª†√ö·ª§√ô·ª¶≈®∆Ø·ª®·ª∞·ª™·ª¨·ªÆ√ù·ª¥·ª≤·ª∂·ª∏ƒê]+(?=[^aƒÉ√¢e√™iou√¥∆°∆∞y\s])', '', text)
        
        encoding_fixes = {
            '√¢‚Ç¨‚Ñ¢': "'",
            '√¢‚Ç¨≈ì': '"', 
            '√¢‚Ç¨': '"',
            '√¢‚Ç¨"': '-',
            '√¢‚Ç¨¬¶': '...',
            '√É¬°': '√°',
            '√É ': '√†',
            '√É¬¢': '√¢',
            '√É¬£': '√£',
            '√É¬®': '√®',
            '√É¬©': '√©',
            '√É¬™': '√™',
            '√É¬¨': '√¨',
            '√É¬≠': '√≠',
            '√É¬≤': '√≤',
            '√É¬≥': '√≥',
            '√É¬¥': '√¥',
            '√É¬π': '√π',
            '√É¬∫': '√∫',
            '√É¬Ω': '√Ω',
            '√Ñ': 'ƒë',
            '√Ñ': 'ƒê'
        }
        
        for wrong, correct in encoding_fixes.items():
            text = text.replace(wrong, correct)
        
        # Clean up spaces and newlines only
        text = re.sub(r'\s+', ' ', text)
        text = re.sub(r'\n{3,}', '\n\n', text)
        
        return text.strip()
    
    def _get_safe_fallback_response(self, user_message=''):
        """Safe fallback response with proper UTF-8"""
        return f"""Xin ch√†o! T√¥i ƒë√£ nh·∫≠n ƒë∆∞·ª£c c√¢u h·ªèi c·ªßa b·∫°n. 

Hi·ªán t·∫°i h·ªá th·ªëng ƒëang ƒë∆∞·ª£c c·∫£i thi·ªán ƒë·ªÉ ph·ª•c v·ª• b·∫°n t·ªët h∆°n. Trong th·ªùi gian n√†y, b·∫°n c√≥ th·ªÉ:

‚Ä¢ Li√™n h·ªá tr·ª±c ti·∫øp: 0274.xxx.xxxx
‚Ä¢ Email: info@bdu.edu.vn  
‚Ä¢ Website: www.bdu.edu.vn

C·∫£m ∆°n b·∫°n ƒë√£ ki√™n nh·∫´n! üòä"""

class PersonalizedChatContextView(APIView):
    """L·∫•y context c√° nh√¢n h√≥a cho chat"""
    
    def get(self, request):
        """GET method - L·∫•y personalized context"""
        try:
            if not request.user.is_authenticated:
                return Response({
                    'personalization_enabled': False,
                    'message': 'User not authenticated'
                }, status=status.HTTP_401_UNAUTHORIZED)
            
            user = request.user
            user_context = user.get_chatbot_context()
            
            # Th√™m th√¥ng tin h·ªØu √≠ch cho frontend
            context_info = {
                'personalization_enabled': True,
                'user_context': user_context,
                'personalized_greeting': f"Ch√†o {user_context.get('position_name', 'gi·∫£ng vi√™n')} {user.full_name}!",
                'department_focus': user_context.get('department_name', 'BDU'),
                'suggested_topics': _get_suggested_topics_for_department(user.department),
                'quick_actions': _get_quick_actions_for_position(user.position),
                'chatbot_tips': [
                    f"H·ªèi v·ªÅ th√¥ng tin chuy√™n ng√†nh {user_context.get('department_name')}",
                    f"T√¨m hi·ªÉu quy ƒë·ªãnh d√†nh cho {user_context.get('position_name')}",
                    "H·ªèi v·ªÅ c∆° s·ªü v·∫≠t ch·∫•t v√† thi·∫øt b·ªã",
                    "T∆∞ v·∫•n v·ªÅ nghi√™n c·ª©u v√† h·ª£p t√°c"
                ]
            }
            
            return Response(context_info, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Personalized context error: {str(e)}")
            return Response({
                'personalization_enabled': False,
                'error': 'Could not load personalized context',
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class PersonalizedSystemStatusView(APIView):
    """System status v·ªõi th√¥ng tin personalization"""
    
    def get(self, request):
        """GET method - System status v·ªõi personalization"""
        try:
            # L·∫•y system status c∆° b·∫£n
            status_data = chatbot_ai.get_system_status()
            speech_status = speech_service.get_system_status()
            
            # Th√™m th√¥ng tin personalization
            personalization_status = {
                'personalization_enabled': True,
                'total_faculty': 0,
                'departments_available': [],
                'positions_available': []
            }
            
            if request.user.is_authenticated:
                user_context = request.user.get_chatbot_context()
                personalization_status.update({
                    'user_department': user_context.get('department_name', 'Unknown'),
                    'user_position': user_context.get('position_name', 'Unknown'),
                    'has_preferences': bool(request.user.chatbot_preferences),
                    'personalized_prompts_available': True
                })
            
            # L·∫•y th·ªëng k√™ t·ª´ database
            try:
                from authentication.models import Faculty
                personalization_status['total_faculty'] = Faculty.objects.count()
                personalization_status['departments_available'] = [
                    choice[1] for choice in Faculty.DEPARTMENT_CHOICES
                ]
                personalization_status['positions_available'] = [
                    choice[1] for choice in Faculty.POSITION_CHOICES
                ]
            except:
                pass
            
            # Merge v·ªõi system status
            status_data.update({
                'personalization': personalization_status,
                'speech_status': speech_status
            })
            
            return Response(status_data, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"System status error: {str(e)}")
            return Response({
                'error': 'Could not retrieve system status',
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# ‚úÖ TH√äM: Helper functions (copy t·ª´ authentication/views.py)
def _get_suggested_topics_for_department(department):
    """L·∫•y c√°c ch·ªß ƒë·ªÅ g·ª£i √Ω theo ng√†nh"""
    topics_map = {
        'cntt': ['Ch∆∞∆°ng tr√¨nh ƒë√†o t·∫°o CNTT', 'Ph√≤ng lab tin h·ªçc', 'Thi·∫øt b·ªã m√°y t√≠nh', 'H·ª£p t√°c doanh nghi·ªáp IT'],
        'duoc': ['Ch∆∞∆°ng tr√¨nh ƒë√†o t·∫°o D∆∞·ª£c', 'Ph√≤ng th√≠ nghi·ªám D∆∞·ª£c', 'Thi·∫øt b·ªã ph√¢n t√≠ch', 'Th·ª±c t·∫≠p b·ªánh vi·ªán'],
        'dien_tu': ['Ch∆∞∆°ng tr√¨nh ƒêi·ªán t·ª≠', 'Lab vi x·ª≠ l√Ω', 'Thi·∫øt b·ªã ƒëo l∆∞·ªùng', 'D·ª± √°n IoT'],
        'co_khi': ['Ch∆∞∆°ng tr√¨nh C∆° kh√≠', 'Ph√≤ng CAD/CAM', 'M√°y gia c√¥ng CNC', 'Th·ª±c t·∫≠p nh√† m√°y'],
        'y_khoa': ['Ch∆∞∆°ng tr√¨nh Y khoa', 'Ph√≤ng gi·∫£i ph·∫´u', 'Th·ª±c h√†nh l√¢m s√†ng', 'B·ªánh vi·ªán li√™n k·∫øt'],
        'kinh_te': ['Ch∆∞∆°ng tr√¨nh Kinh t·∫ø', 'Ph·∫ßn m·ªÅm ph√¢n t√≠ch', 'Th·ª±c t·∫≠p ng√¢n h√†ng', 'Nghi√™n c·ª©u th·ªã tr∆∞·ªùng'],
        'luat': ['Ch∆∞∆°ng tr√¨nh Lu·∫≠t', 'Phi√™n t√≤a gi·∫£ ƒë·ªãnh', 'Th·ª±c t·∫≠p t√≤a √°n', 'VƒÉn ph√≤ng lu·∫≠t s∆∞']
    }
    return topics_map.get(department, ['Th√¥ng tin chung v·ªÅ tr∆∞·ªùng', 'Quy ƒë·ªãnh ƒë√†o t·∫°o', 'C∆° s·ªü v·∫≠t ch·∫•t'])

def _get_quick_actions_for_position(position):
    """L·∫•y c√°c quick actions theo ch·ª©c v·ª•"""
    actions_map = {
        'giang_vien': ['Xem l·ªãch gi·∫£ng d·∫°y', 'Qu·∫£n l√Ω ƒëi·ªÉm sinh vi√™n', 'T√†i li·ªáu gi·∫£ng d·∫°y', 'Nghi√™n c·ª©u khoa h·ªçc'],
        'truong_khoa': ['Qu·∫£n l√Ω khoa', 'K·∫ø ho·∫°ch ƒë√†o t·∫°o', 'B√°o c√°o ho·∫°t ƒë·ªông', 'Nh√¢n s·ª± khoa'],
        'truong_bo_mon': ['Qu·∫£n l√Ω b·ªô m√¥n', 'Ph√¢n c√¥ng gi·∫£ng d·∫°y', 'T√†i li·ªáu chuy√™n ng√†nh', 'Ho·∫°t ƒë·ªông chuy√™n m√¥n'],
        'tro_giang': ['H·ªó tr·ª£ gi·∫£ng d·∫°y', 'Chu·∫©n b·ªã b√†i gi·∫£ng', 'Ch·∫•m b√†i t·∫≠p', 'T∆∞∆°ng t√°c sinh vi√™n']
    }
    return actions_map.get(position, ['Th√¥ng tin chung', 'H·ªó tr·ª£ k·ªπ thu·∫≠t', 'Li√™n h·ªá ph√≤ng ban'])


# ‚úÖ Speech-to-Text Views
class SpeechToTextView(APIView):
    """
    API endpoint for Speech-to-Text conversion
    Accepts audio file upload and returns transcribed text
    """
    
    def get(self, request):
        """GET method - Service information"""
        speech_status = speech_service.get_system_status()
        return Response({
            'message': 'Speech-to-Text API',
            'method': 'POST ƒë·ªÉ upload audio file',
            'speech_service': speech_status,
            'supported_formats': speech_service.supported_formats,
            'max_file_size_mb': speech_service.max_file_size_mb,
            'usage': {
                'method': 'POST',
                'content_type': 'multipart/form-data',
                'fields': {
                    'audio': 'Audio file (required)',
                    'language': 'Language code (optional, default: vi)',
                    'beam_size': 'Beam size for better accuracy (optional, default: 5)'
                }
            }
        })
    
    def post(self, request):
        """POST method - Process audio file v·ªõi enhanced debugging"""
        start_time = time.time()
        
        try:
            # Check if service is available
            if not speech_service.is_available():
                logger.error("üö® Speech service not available")
                return Response({
                    'success': False,
                    'error': 'Speech-to-Text service not available. Please install faster-whisper.',
                    'text': '',
                    'status': speech_service.get_system_status()
                }, status=status.HTTP_503_SERVICE_UNAVAILABLE)
            
            # Check if file is in request
            if 'audio' not in request.FILES:
                logger.error("üö® No audio file in request")
                return Response({
                    'success': False,
                    'error': 'No audio file provided. Please upload an audio file.'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            audio_file = request.FILES['audio']
            
            # ‚úÖ ENHANCED DEBUG LOGGING
            logger.info(f"üé§ Received audio file: {audio_file.name}")
            logger.info(f"üé§ File size: {audio_file.size} bytes ({audio_file.size / 1024 / 1024:.2f} MB)")
            logger.info(f"üé§ Content type: {audio_file.content_type}")
            
            # Validate file size
            if audio_file.size > speech_service.max_file_size_mb * 1024 * 1024:
                logger.error(f"üö® File too large: {audio_file.size} bytes")
                return Response({
                    'success': False,
                    'error': f'File too large. Maximum size: {speech_service.max_file_size_mb}MB'
                }, status=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE)
            
            # ‚úÖ CHECK: Minimum file size
            if audio_file.size < 1024:  # Less than 1KB
                logger.error(f"üö® File too small: {audio_file.size} bytes")
                return Response({
                    'success': False,
                    'error': 'Audio file too small. Please record longer audio.',
                    'text': ''
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # Get optional parameters
            language = request.data.get('language', 'vi')
            beam_size = int(request.data.get('beam_size', 5))
            
            logger.info(f"üé§ Processing with language={language}, beam_size={beam_size}")
            
            # Save uploaded file to temporary location
            with tempfile.NamedTemporaryFile(
                delete=False, 
                suffix=os.path.splitext(audio_file.name)[1] or '.webm'
            ) as tmp_file:
                # Write file data
                bytes_written = 0
                for chunk in audio_file.chunks():
                    tmp_file.write(chunk)
                    bytes_written += len(chunk)
                tmp_file.flush()
                
                logger.info(f"üé§ Saved temp file: {tmp_file.name} ({bytes_written} bytes)")
                
                try:
                    # Process with speech service
                    logger.info("üîÑ Starting transcription...")
                    result = speech_service.transcribe_audio(
                        tmp_file.name,
                        language=language,
                        beam_size=beam_size
                    )
                    
                    # ‚úÖ ENHANCED RESULT LOGGING
                    logger.info(f"üîç Transcription result: {result}")
                    
                    if result.get('success'):
                        transcribed_text = result.get('text', '').strip()
                        logger.info(f"‚úÖ Transcribed text: '{transcribed_text}' (length: {len(transcribed_text)})")
                        
                        if not transcribed_text:
                            logger.warning("‚ö†Ô∏è Empty transcription result")
                            return Response({
                                'success': False,
                                'error': 'No speech detected in audio. Please speak louder or check microphone.',
                                'text': '',
                                'debug_info': result
                            }, status=status.HTTP_200_OK)
                    else:
                        logger.error(f"‚ùå Transcription failed: {result.get('error')}")
                    
                    # Add additional metadata
                    result['file_name'] = audio_file.name
                    result['file_size_mb'] = round(audio_file.size / (1024 * 1024), 2)
                    result['total_processing_time'] = time.time() - start_time
                    
                    return Response(result, status=status.HTTP_200_OK)
                    
                finally:
                    # ‚úÖ FIX: Clean up temporary file with better error handling
                    try:
                        if os.path.exists(tmp_file.name):
                            # Brief delay for Windows file system
                            import threading
                            def delayed_cleanup():
                                import time as time_module  # ‚úÖ FIX: Use different name
                                time_module.sleep(0.1)
                                try:
                                    os.unlink(tmp_file.name)
                                    logger.info(f"üóëÔ∏è Cleaned up temp file: {tmp_file.name}")
                                except:
                                    pass
                            
                            # Run cleanup in background thread
                            cleanup_thread = threading.Thread(target=delayed_cleanup)
                            cleanup_thread.daemon = True
                            cleanup_thread.start()
                            
                    except Exception as cleanup_error:
                        logger.warning(f"‚ö†Ô∏è Failed to cleanup temp file: {cleanup_error}")
                        # Not a critical error, continue
        
        except Exception as e:
            logger.error(f"üí• Speech-to-text error: {str(e)}")
            import traceback
            logger.error(f"üí• Full traceback: {traceback.format_exc()}")
            
            return Response({
                'success': False,
                'error': f'Server error: {str(e)}',
                'text': '',
                'processing_time': time.time() - start_time
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class SpeechStatusView(APIView):
    """
    Get Speech-to-Text service status and capabilities
    """
    
    def get(self, request):
        """GET method - Service status"""
        try:
            speech_status = speech_service.get_system_status()
            
            return Response({
                'status': 'ok',
                'message': 'Speech-to-Text Service Status',
                'speech_service': speech_status,
                'endpoints': {
                    'speech_to_text': '/api/speech-to-text/',
                    'speech_status': '/api/speech-status/'
                },
                'capabilities': {
                    'languages': ['vi', 'en'],  # Vietnamese and English
                    'supported_formats': speech_service.supported_formats,
                    'max_file_size_mb': speech_service.max_file_size_mb,
                    'features': [
                        'Voice Activity Detection',
                        'Noise Suppression', 
                        'Automatic Language Detection',
                        'GPU Acceleration (if available)'
                    ]
                }
            }, status=status.HTTP_200_OK)
        
        except Exception as e:
            logger.error(f"Error getting speech status: {str(e)}")
            return Response({
                'status': 'error',
                'error': str(e),
                'speech_service': {
                    'available': False,
                    'error': 'Service status check failed'
                }
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# ‚úÖ EXISTING VIEWS - Unchanged
class ChatHistoryView(APIView):
    def get(self, request, session_id=None):
        try:
            if session_id:
                history = ChatHistory.objects.filter(session_id=session_id).order_by('timestamp')
            else:
                history = ChatHistory.objects.all().order_by('-timestamp')[:50]
            
            data = [{
                'id': chat.id,
                'session_id': chat.session_id,
                'user_message': chat.user_message,
                'bot_response': chat.bot_response,
                'timestamp': chat.timestamp.isoformat(),
                'confidence': chat.confidence_score,
                'response_time': chat.response_time
            } for chat in history]
            
            return Response({
                'count': len(data),
                'results': data
            })
            
        except Exception as e:
            logger.error(f"Error getting chat history: {str(e)}")
            return Response(
                {'error': 'Kh√¥ng th·ªÉ l·∫•y l·ªãch s·ª≠ chat'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class FeedbackView(APIView):
    def post(self, request):
        try:
            chat_id = request.data.get('chat_id')
            feedback_type = request.data.get('feedback_type')
            comment = request.data.get('comment', '')
            
            if not chat_id or not feedback_type:
                return Response(
                    {'error': 'chat_id v√† feedback_type l√† b·∫Øt bu·ªôc'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            try:
                chat_history = ChatHistory.objects.get(id=chat_id)
            except ChatHistory.DoesNotExist:
                return Response(
                    {'error': 'Kh√¥ng t√¨m th·∫•y cu·ªôc tr√≤ chuy·ªán'}, 
                    status=status.HTTP_404_NOT_FOUND
                )
            
            feedback = UserFeedback.objects.create(
                chat_history=chat_history,
                feedback_type=feedback_type,
                comment=comment
            )
            
            return Response({
                'message': 'C·∫£m ∆°n ph·∫£n h·ªìi c·ªßa b·∫°n!',
                'feedback_id': feedback.id
            })
            
        except Exception as e:
            logger.error(f"Error saving feedback: {str(e)}")
            return Response(
                {'error': 'Kh√¥ng th·ªÉ l∆∞u ph·∫£n h·ªìi'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class HealthCheckView(APIView):
    def get(self, request):
        try:
            system_status = chatbot_ai.get_system_status()
            speech_status = speech_service.get_system_status()  # ‚Üê TH√äM
            
            return Response({
                'status': 'healthy',
                'message': 'Natural Language Chatbot with Speech-to-Text is running! üöÄ',
                'database': 'connected',
                'encoding': 'utf-8',
                'system_status': system_status,
                'speech_status': speech_status,  # ‚Üê TH√äM
                'version': '3.1.0'  # ‚Üê TƒÉng version
            })
        except Exception as e:
            return Response({
                'status': 'unhealthy',
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)